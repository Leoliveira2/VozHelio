<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Modificador de Voz</title>
  <style>
    body { font-family: sans-serif; background: #f4f4f4; text-align: center; padding: 20px; }
    h1 { margin-bottom: 20px; }
    button { padding: 10px 15px; margin: 5px; font-size: 16px; border-radius: 8px; border: none; cursor: pointer; }
    #record { background: #007bff; color: white; }
    #stop { background: #dc3545; color: white; }
    .effect { background: #28a745; color: white; }
    audio { margin-top: 20px; width: 100%; max-width: 400px; }
  </style>
</head>
<body>

<h1>🎙️ Modificador de Voz</h1>

<button id="record">🎤 Gravar</button>
<button id="stop" disabled>🛑 Parar</button>

<div id="effects" style="display:none;">
  <p>Efeitos:</p>
  <button class="effect" onclick="playEffect('normal')">▶️ Original</button>
  <button class="effect" onclick="playEffect('helium')">🎈 Hélio</button>
  <button class="effect" onclick="playEffect('deep')">💀 Grave</button>
  <button class="effect" onclick="playEffect('robot')">🤖 Robô</button>
  <button class="effect" onclick="playEffect('echo')">🌌 Eco</button>
</div>

<audio id="player" controls style="display:none;"></audio>

<script>
let mediaRecorder, audioChunks = [], audioBlob, audioBuffer;
const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();
const player = document.getElementById('player');

document.getElementById('record').onclick = async () => {
  audioChunks = [];
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  mediaRecorder = new MediaRecorder(stream);
  mediaRecorder.start();
  mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
  mediaRecorder.onstop = async () => {
    audioBlob = new Blob(audioChunks, { type: 'audio/ogg; codecs=opus' }); // melhor compatibilidade
    player.src = URL.createObjectURL(audioBlob);
    player.style.display = 'block';
    document.getElementById('effects').style.display = 'block';

    // Decodifica para efeitos
    const arrayBuffer = await audioBlob.arrayBuffer();
    audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
  };
  document.getElementById('record').disabled = true;
  document.getElementById('stop').disabled = false;
};

document.getElementById('stop').onclick = () => {
  mediaRecorder.stop();
  document.getElementById('record').disabled = false;
  document.getElementById('stop').disabled = true;
};

function playEffect(type) {
  if (!audioBuffer) return;

  const source = audioCtx.createBufferSource();
  source.buffer = audioBuffer;
  let node = source;

  switch (type) {
    case 'helium':
      source.playbackRate.value = 1.7;
      break;

    case 'deep':
      source.playbackRate.value = 0.6;
      break;

    case 'robot': {
      const gainNode = audioCtx.createGain();
      const osc = audioCtx.createOscillator();
      osc.frequency.value = 100;
      osc.connect(gainNode.gain);
      osc.start();
      node.connect(gainNode);
      node = gainNode;
      break;
    }

    case 'echo': {
      const delay = audioCtx.createDelay();
      delay.delayTime.value = 0.25;
      const feedback = audioCtx.createGain();
      feedback.gain.value = 0.4;
      delay.connect(feedback);
      feedback.connect(delay);
      node.connect(delay);
      node = delay;
      break;
    }

    case 'normal':
    default:
      source.playbackRate.value = 1;
  }

  node.connect(audioCtx.destination);
  source.start();
}
</script>

</body>
</html>
